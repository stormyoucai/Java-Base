1、关于进程和线程：
对于word来说，启动word实际上就是在操作系统上分配了一个进程，
线程是进程的进一步划分，从word来看，可以把拼写检查当做一个线程，但是word上会同时存在多个线程
如果进程没有了，线程肯定消失，如果线程没有了，进程不一定消失，所有的线程都是在进程的基础上同时运行的

2、Java中实现多线程有两种方式：
    继承Thread类
        一个类只要继承了Thread类，此类就称为多线程操作类，其子类必须明确的覆写Thread类中的run()方法，该方法是线程的主体
    实现Runnable接口
        可以通过实现Runnable接口的方式实现多线程，该接口中只定义了一个抽象方法：run()
        观察Thread类的构造方法：可以接受一个Runnable接口的参数

3、如果要想启动一个线程必须使用Thread类中的定义的start()方法，一旦调用start()方法，实际上最终调用的就是run()方法

4、启动线程的时候为什么不直接调用run()方法，而是通过start()调用呢？
看源码，点进去看start()方法：
start0()方法中有native关键字声明，native关键字表示的是一个有Java调用本机操作系统函数的一个关键字；要想实现多线程，肯定需要操作系统的支持，因为需要抢占cpu；
而且在各个操作系统中多线程的底层实现代码肯定是不同的，所以使用native关键字也可以让JVM自动去调整不同的JVM实现。

5、Thread类 和Runnable接口的关系：
从定义上看，Thread类是Runnable接口的子类，从类的关系上看，类似于代理设计模式；
    使用Thread类在操作多线程的时候无法达到资源共享：因为每一个对象中都包含各自的属性（会有多个对象）
    而使用Runnable接口实现的多线程操作可以实现资源共享：而使用Runnable可以达到资源共享，因为其启动多线程用的是同一个对象

7、实现Runnable接口比继承Thread类的优点：
    适合多个相同程序处理同一资源（因为其资源共享）
    避免单继承局限
    在开发中，尽量使用Runnable接口

8、线程的状态：
    创建状态：准备好了一个多线程对象：Thread t = new Thread()
    就绪状态: 调用了start()方法，等待CPU进行调度
    运行状态：执行run()方法
    阻塞状态：暂时停止执行，可能将资源交由其他线程使用
    终止状态：线程执行完毕，不再使用了


总结：
1、进程与线程的区别

2、Java实现多线程的两种方式

3、线程启动：通过start()方法，需要等待cpu调度，start()实际上调用的是run()

4、Thread是Runnable的子类，使用了代理机制完成

5、尽量使用Runnable即开发，使用Runnable实现多线程的好处

6、线程的状态


参考博客：
    1、并发与并行的区别：
    http://ifeve.com/parallel_and_con/